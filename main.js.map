{
  "version": 3,
  "sources": ["src/main.ts", "src/infrastructure/ai/GeminiProvider.ts", "src/core/services/GeminiAnalyzer.ts", "src/workflow/HighlightWorkflow.ts", "src/ui/SettingsTab.ts"],
  "sourcesContent": ["import { Plugin, Notice, MarkdownView, Editor } from 'obsidian';\r\nimport { GeminiProvider } from \"./infrastructure/ai/GeminiProvider\";\r\nimport { GeminiAnalyzer } from \"./core/services/GeminiAnalyzer\";\r\nimport { HighlightWorkflow } from './workflow/HighlightWorkflow';\r\nimport { HighlightResult } from './core/interfaces/HighlightResult';\r\nimport { AutomaticHighlighterSettingsTab } from './ui/SettingsTab';\r\n\r\ninterface AutomaticHighlighterSettings {\r\n    geminiApiKey: string;\r\n}\r\n\r\nconst DEFAULT_SETTINGS: AutomaticHighlighterSettings = {\r\n    geminiApiKey: \"\"\r\n};\r\n\r\nexport default class AutomaticHighlighter extends Plugin {\r\n    \r\n    settings!: AutomaticHighlighterSettings;\r\n\r\n    async onload() {\r\n        console.log('Loading Automatic Highlighter Plugin');\r\n\r\n        // Carrega configura\u00E7\u00F5es salvas\r\n        await this.loadSettings();\r\n        this.addSettingTab(new AutomaticHighlighterSettingsTab(this.app, this));\r\n\r\n        // Registra comandos\r\n        this.registerAnalyzeCommand();\r\n        this.registerNotificationCommand();\r\n        this.registerReloadCommand();\r\n    }\r\n\r\n    onunload() {\r\n        console.log('Unloading Automatic Highlighter Plugin');\r\n    }\r\n\r\n    // ===============================\r\n    // Settings\r\n    // ===============================\r\n    async loadSettings() {\r\n        this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());\r\n    }\r\n\r\n    async saveSettings() {\r\n        await this.saveData(this.settings);\r\n    }\r\n\r\n    // ===============================\r\n    // Comandos\r\n    // ===============================\r\n    private registerAnalyzeCommand() {\r\n        this.addCommand({\r\n            id: \"analyze-and-highlight\",\r\n            name: \"Analyze and Suggest Highlights\",\r\n            callback: async () => await this.executeWorkflow()\r\n        });\r\n    }\r\n\r\n    private registerNotificationCommand() {\r\n        this.addCommand({\r\n            id: 'show-notification',\r\n            name: 'Show Notification',\r\n            callback: () => {\r\n                new Notice('This is a notification from the Automatic Highlighter Plugin!');\r\n            }\r\n        });\r\n    }\r\n\r\n    private registerReloadCommand() {\r\n        this.addCommand({\r\n            id: 'reload-plugin',\r\n            name: 'Reload this plugin',\r\n            callback: async () => {\r\n                const id = this.manifest.id;\r\n                // @ts-ignore\r\n                await this.app.plugins.disablePlugin(id);\r\n                // @ts-ignore\r\n                await this.app.plugins.enablePlugin(id);\r\n                new Notice('Automatic Highlighter plugin reloaded!');\r\n            }\r\n        });\r\n    }\r\n\r\n    // ===============================\r\n    // Fluxo principal\r\n    // ===============================\r\n    private async executeWorkflow() {\r\n        const view = this.app.workspace.getActiveViewOfType(MarkdownView);\r\n        if (!view) return;\r\n\r\n        const editor: Editor = view.editor;\r\n        if (!editor) return;\r\n\r\n        const content = editor.getValue();\r\n\r\n        // Criar provider com API Key do usu\u00E1rio\r\n        const provider = new GeminiProvider(this.settings.geminiApiKey);\r\n\r\n        // Criar analyzer\r\n        const analyzer = new GeminiAnalyzer(provider);\r\n\r\n        // Executar an\u00E1lise\r\n        let highlights: HighlightResult[];\r\n        try {\r\n            highlights = await analyzer.analyze(content);\r\n        } catch (err) {\r\n            console.error(\"Erro ao analisar nota:\", err);\r\n            new Notice(\"Erro ao analisar nota. Veja console para detalhes.\");\r\n            return;\r\n        }\r\n\r\n        if (!highlights || highlights.length === 0) {\r\n            new Notice(\"Nenhum destaque encontrado.\");\r\n            return;\r\n        }\r\n\r\n        // Aplicar highlights usando o workflow existente\r\n        const workflow = new HighlightWorkflow(this.app);\r\n        workflow.run(editor, highlights);\r\n\r\n        new Notice(`Applied ${highlights.length} highlights!`);\r\n    }\r\n}", "import { AIProvider } from \"../../core/interfaces/AIProvider\";\r\n\r\nexport class GeminiProvider implements AIProvider {\r\n  constructor(private apiKey: string) { }\r\n\r\n  async generateContent(prompt: string): Promise<string> {\r\n    const response = await fetch(\r\n      `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${this.apiKey}`,\r\n      {\r\n        method: \"POST\",\r\n        headers: { \"Content-Type\": \"application/json\" },\r\n        body: JSON.stringify({\r\n          contents: [{ parts: [{ text: prompt }] }]\r\n        })\r\n      }\r\n    );\r\n\r\n    const data = await response.json();\r\n    let resultText = data.candidates?.[0]?.content?.parts?.[0]?.text;\r\n\r\n    if (!resultText) {\r\n      throw new Error(\"Resposta do Gemini vazia ou inv\u00E1lida\");\r\n    }\r\n\r\n    // Limpa crases ou markdown extras\r\n    resultText = resultText.replace(/```json|```/g, '').trim();\r\n\r\n    // S\u00F3 loga para debug\r\n    console.log(\"Resposta bruta do Gemini:\", resultText);\r\n\r\n    return resultText; // retorna como string, JSON.parse ser\u00E1 feito no Analyzer\r\n  }\r\n}", "import { AIProvider } from \"../interfaces/AIProvider\";\r\nimport { NoteAnalyzer } from \"../interfaces/NoteAnalyzer\";\r\nimport { HighlightResult } from \"../interfaces/HighlightResult\";\r\n\r\nexport class GeminiAnalyzer implements NoteAnalyzer {\r\n  constructor(private aiProvider: AIProvider) { }\r\n\r\n  async analyze(noteContent: string): Promise<HighlightResult[]> {\r\n    const prompt = this.buildPrompt(noteContent);\r\n    const raw = await this.aiProvider.generateContent(prompt);\r\n\r\n    // Limpa crases, markdown, e espa\u00E7os extras\r\n    let cleaned = raw.replace(/```json|```/g, '').trim();\r\n\r\n    let parsed: { text: string; type: string }[];\r\n\r\n    try {\r\n      parsed = JSON.parse(cleaned);\r\n    } catch (err) {\r\n      console.error(\"JSON inv\u00E1lido recebido do Gemini:\", cleaned);\r\n      throw new Error(`Resposta da IA n\u00E3o \u00E9 JSON v\u00E1lido. Conte\u00FAdo retornado: ${cleaned}`);\r\n    }\r\n\r\n    // Converte para o formato completo com \u00EDndices\r\n    return this.validateAndFix(parsed, noteContent);\r\n  }\r\n\r\n  private buildPrompt(noteContent: string): string {\r\n    return `\r\nVoc\u00EA \u00E9 um assistente que extrai **apenas trechos curtos e significativos** de uma nota, \u00FAteis para estudo (tipo flashcards).\r\n\r\nRegras obrigat\u00F3rias:\r\n1. Retorne **somente JSON v\u00E1lido**, sem markdown, sem crases, sem t\u00EDtulos, sem explica\u00E7\u00F5es.\r\n2. Cada item do array deve conter:\r\n   - \"text\": o trecho exato do texto\r\n   - \"type\": \"definition\", \"concept\" ou \"important\"\r\n   - \"start\": \u00EDndice inicial\r\n   - \"end\": \u00EDndice final\r\n3. Ignore palavras isoladas ou frases triviais; pegue somente trechos relevantes e explicativos.\r\n4. **N\u00C3O use markdown, crases, ou qualquer formata\u00E7\u00E3o**, apenas JSON puro.\r\n5. Retorne **SOMENTE um array JSON v\u00E1lido**. Nada mais.\r\n\r\nExemplo de sa\u00EDda v\u00E1lida:\r\n[\r\n  { \"text\": \"O \u00E1tomo \u00E9 a unidade b\u00E1sica da mat\u00E9ria.\", \"type\": \"definition\", \"start\": 0, \"end\": 38 },\r\n  { \"text\": \"A fotoss\u00EDntese converte luz em energia.\", \"type\": \"concept\", \"start\": 50, \"end\": 90 }\r\n]\r\n\r\nTexto da nota:\r\n\"\"\"\r\n${noteContent}\r\n\"\"\"\r\n`;\r\n  }\r\n\r\n  private validateAndFix(\r\n    results: { text: string; type: string }[],\r\n    content: string\r\n  ): HighlightResult[] {\r\n    return results\r\n      .map(item => {\r\n        const start = content.indexOf(item.text);\r\n        if (start === -1) return null;\r\n\r\n        return {\r\n          text: item.text,\r\n          type: item.type,\r\n          start,\r\n          end: start + item.text.length\r\n        };\r\n      })\r\n      .filter(Boolean) as HighlightResult[];\r\n  }\r\n}", "import { App, Editor } from 'obsidian';\r\nimport { HighlightResult } from '../core/interfaces/HighlightResult';\r\n\r\nexport class HighlightWorkflow {\r\n    constructor(private app: App) {}\r\n\r\n    // Adicione highlights como argumento opcional\r\n    run(editor: Editor, highlights: HighlightResult[]) {\r\n    if (!highlights || highlights.length === 0) return;\r\n\r\n    // Ordena do maior start para o menor\r\n    const sorted = highlights.sort((a, b) => b.start - a.start);\r\n\r\n    let text = editor.getValue();\r\n\r\n    sorted.forEach(h => {\r\n        text = text.slice(0, h.start) + `==${h.text}==` + text.slice(h.end);\r\n    });\r\n\r\n    editor.setValue(text);\r\n}\r\n}", "import { App, PluginSettingTab, Setting } from 'obsidian';\r\nimport { AutomaticHighlighterSettings } from './main';\r\n\r\nexport class AutomaticHighlighterSettingsTab extends PluginSettingTab {\r\n    plugin: any;\r\n\r\n    constructor(app: App, plugin: any) {\r\n        super(app, plugin);\r\n        this.plugin = plugin;\r\n    }\r\n\r\n    display(): void {\r\n        const { containerEl } = this;\r\n\r\n        containerEl.empty();\r\n\r\n        containerEl.createEl('h2', { text: 'Configura\u00E7\u00F5es do Automatic Highlighter' });\r\n\r\n        new Setting(containerEl)\r\n            .setName('Gemini API Key')\r\n            .setDesc('Digite sua chave da API do Gemini aqui.')\r\n            .addText(text => \r\n                text\r\n                    .setPlaceholder('Insira sua API key')\r\n                    .setValue(this.plugin.settings.geminiApiKey)\r\n                    .onChange(async (value) => {\r\n                        this.plugin.settings.geminiApiKey = value;\r\n                        await this.plugin.saveSettings();\r\n                    })\r\n            );\r\n    }\r\n}"],
  "mappings": "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",
  "names": ["import_obsidian"]
}
